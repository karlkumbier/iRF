plotInt2 <- function(rectangles, interact, x, y, 
                     grid.size=100, col.pal=c('blue', 'yellow'), 
                     xlab=NULL, ylab=NULL, zlab=NULL,
                     range.color=NULL,
                     z.range=c(0,1),
                     n.cols=100, grids=NULL, axes=TRUE,
                     varnames.grp=colnames(x),
                     pred.prob=FALSE, min.node=10) {
  # Generates surface map of order-2 interaction
  # args:
  #   rectangles: hyprerectangle list as generated by forestHyperrectangle
  #   interact.plot: order-2 interaction to plot
  #   grid.size: number of bins to plot surface map over
  #   col.pal: color palette of surface map
  #   xlab, ylab, zlab: axis labels
  #   range.color: range of color values
  #   z.range: range for response axis
  #   n.cols: number of colors in color pal
  #   grids: user generated grid to plot over. If supplied, grid.size is 
  #     ignored
  #   axes: T/F indicating whether axes should be plotted
  #   varnames.group: character vector indicating feature grouping
  #   groupFUN: function to use for grouping columns of x
  #   pred.prob: T/F indicating whether the z axis should indicate predicted
  #     probability from the forest or raw data distribution
  #   min.node.size: minimum leaf node size to use for grid
  require(rgl)
  
  if (is.null(varnames.grp)) varnames.grp <- 1:ncol(x)
  interact <- int2Id(interact, varnames.grp, signed=TRUE, split=TRUE)
  stopifnot(length(interact) == 2) 
  
  n <- nrow(x)
  p <- ncol(x)
  if (is.factor(y)) y <- as.numeric(y) - 1
  
  # generate grid to plot surface over either as raw values or quantiles
  int1 <- interact[1]
  int2 <- interact[2]
  
  if (is.null(grids)) {
    i1 <- int1 %% p + p * (int1 %% p == 0)
    i2 <- int2 %% p + p * (int2 %% p == 0)
    g1 <- seq(min(x[,i1]), max(x[,i1]), length.out=grid.size)
    g2 <- seq(min(x[,i2]), max(x[,i2]), length.out=grid.size)
    g1n <- round(g1, 2)
    g2n <- round(g2, 2)
  } else {
    g1 <- grids$g1
    g2 <- grids$g2
    g1n <- seq(0, 1, length.out=length(g1))
    g2n <- seq(0, 1, length.out=length(g2))
    grid.size <- length(g1)
  }
  
  # Evaluate responses over grid based on RF hyperrectangles
  grid <- matrix(0, nrow=grid.size, ncol=grid.size)
  rectangles <- filter(rectangles, size.node >= min.node)
  removed <- rep(FALSE, nrow(rectangles))
  for (i in 1:nrow(rectangles)) {
    
    rtemp <- rectangles[i,]
    tt1 <- unlist(rtemp$splits)[unlist(rtemp$vars) == int1]
    tt2 <- unlist(rtemp$splits)[unlist(rtemp$vars) == int2]
    
    if (int1 <= p) {
      idcs1 <- g1 < tt1
      x1 <- x[, intp1] < tt1
    } else {
      idcs1 <- g1 >= tt1
      int11 <- int1 %% p + p * (int1 %% p == 0)
      x1 <- x[,int11] >= tt1
    }
    
    if (int2 <= p) {
      idcs2 <- g2 < tt2
      x2 <- x[, intp2] < tt2
    } else {
      idcs2 <- g2 >= tt2
      int22 <- int2 %% p + p * (int2 %% p == 0)
      x2 <- x[,int22] >= tt2
    }
    
    if (pred.prob) {
      yy <- rectangles$prediction[i]
      grid[idcs1, idcs2] <- grid[idcs1, idcs2] + yy * rectangles$size.node[i]
    } else {
      # Evaluate average response in partitioned space
      
      if (!any(x1 & x2)) {
        # Remove regions containing no observations
        removed[i] <- TRUE
        next
      }
      
      # Evaluate distribution of responses in interaction region and its
      # compliment
      yr <- mean(y[x1 & x2])
      yrc <- mean(y[!x1 | !x2])
      wt <- rectangles$size.node[i]
      
      grid[idcs1, idcs2] <- grid[idcs1, idcs2] +  yr * wt
      grid[!idcs1, idcs2] <- grid[!idcs1, idcs2] + yrc * wt
      grid[idcs1, !idcs2] <- grid[idcs1, !idcs2] + yrc * wt
      grid[!idcs1, !idcs2] <- grid[!idcs1, !idcs2] + yrc * wt
      
    }
  }
  
  # rescale surface for node size 
  grid <- (grid / sum(rectangles$size.node[!removed]))
  
  if (is.null(range.color)) range.color <- range(grid)
  palette <- colorRampPalette(col.pal)
  colors <- palette(n.cols)
  facet.col <- cut(c(range.color, as.vector(grid)), n.cols)[-seq(2)]
  
  persp3d(x=g1n, y=g2n, z=grid, 
          xlab=xlab,
          ylab=ylab,
          zlab=zlab, zlim=z.range, 
          col=colors[facet.col],
          axes=axes)
  
}

facetSurface <- function(int, nf, tree.info, varnames.grp, x, 
                         y, qcut=0.5, xlab, ylab, min.node, plot.dir) {
  # Generates surface plots for first two interacting features by levels 
  # of the remaining features
  # args:
  #   int: interaction to plot
  #   nf: a node feature sparse matrix, as returned from readForest
  #   tree.info: leaf node metadata, as returned by readForest
  #   varnames.group: character vector indicating feature groupings
  #   x: data matrix, possibly containing replicate features
  #   xg:
  
  # evaluate median thresholds for faceting variables
  id.int <- int2Id(int, varnames.grp=varnames.grp, split=TRUE, signed=TRUE)
  id.nf <- apply(nf[,id.int], MAR=1, function(z) all(z != 0))
  qq <- function(x) quantile(x, probs = qcut)
  thresholds <- apply(nf[id.nf, id.int], MAR=2, qq)
  sgn <- intSign(int)
  
  if (length(int) > 2) {
    id.facet <- 3:length(int)
    int.clean <- gsub('[-\\+]', '', int)
    xx <- t(x[,int.clean[id.facet]]) * sgn[id.facet]
    thresholds[id.facet] <- thresholds[id.facet] * sgn[id.facet]
    id <- xx > thresholds[id.facet]
    id <- apply(id, MAR=1, as.numeric)
    id <- apply(id, MAR=1, paste, collapse='_')
  } else {
    int.clean <- gsub('[-\\+]', '', int)
    id <- rep(1, nrow(x))
    id.facet <- 1:2
  }
  
  grids <- quantileGrid(x, 50, interact=int.clean[1:2])
  
  rectangles <- forestHyperrectangle(tree.info=tree.info, nf=nf, 
                                     x=x, y=y, 
                                     interact=int, 
                                     varnames.grp=varnames.grp, 
                                     min.node.size=min.node)
  
  
  # iterate through each facet and generate surface plot
  for (ii in unique(id)) {
    open3d()
    id.cur <- id == ii
    nn <- sum(id.cur)
    if (nn < 100) {
      print(ii) 
      next
    }
    
    plotInt2(rectangles, interact=int[1:2], x=x[id.cur,], 
             y=as.factor(y[id.cur]), varnames.grp=varnames.grp, 
             min.node=min.node, grids=grids,
             xlab=xlab, ylab=ylab, zlab='P(Y=1)')
    
    if (!is.null(plot.dir)) {
      pp <- paste(int.clean[id.facet], collapse='_')
      sub.dir <- paste0(plot.dir, pp, '-', ii, '_n', nn)
      dir.create(sub.dir, recursive=TRUE)
      rgl.viewpoint(zoom=0.85, theta=0, phi=-75)
      movie3d(spin3d(axis = c(0,0,1), rpm = 10), duration=6,  type="png", 
              dir=sub.dir, convert=FALSE, clean=FALSE)
    }
  }
}



getPathsTree <- function(tree.info, nf, interact) {
  # Extract decision paths across all leaf nodes in a given tree.
  # args:
  #   tree.info: data frame as returned by readForest
  #   nf: a node feature sparse matrix, as returned by readForest
  #   interact: a numeric vector indicating interaciton variables
  require(data.table)
  require(dplyr)
  
  out <- select(tree.info, prediction, node.idx, tree, size.node)
  out$vars <- apply(nf, MAR=1, function(z) which(z != 0))
  out$splits <- apply(nf, MAR=1, function(z) z[which(z != 0)])
  id <- sapply(out$vars, function(z) all(interact %in% z))
  out <- out[id,]
  
  return(out)
}

forestHyperrectangle <- function(tree.info, nf, x, y, interact, 
                                 varnames.grp=NULL, min.node.size=1) {
  # Read hyperrectangles from RF for a specified interactin
  # args:
  #   tree.info: data frame as returned by readForest
  #   nf: a node feature sparse matrix, as returned by readForest
  #   x: data matrix
  #   y: response vector
  #   varnames.group: character vector indicating feature grouping
  #   interact: vector of features for which to generate hyperrectangles
  #   min.node.size: filter all leaf nodes that are not larger than specified 
  #     value for faster processing
  
  interact <- strsplit(interact, '_')[[1]]
  if (is.null(varnames.grp)) varnames.grp <- 1:ncol(x)
  interact <- int2Id(interact, varnames.grp, signed=TRUE, split=TRUE)

  print('Extracting paths...')
  out <- getPathsTree(tree.info, nf, interact) 

  # if min.node.size < 1, it is assumed to be given as quantile
  if (min.node.size < 1 & is.factor(y)) { 
    m1 <- quantile(out$size.node[out$prediction == 2], min.node.size)
    m0 <- quantile(out$size.node[out$prediction == 1], min.node.size)
    out <- filter(out, size.node > m1 & prediction == 2 | 
                    size.node > m0 & prediction == 1)
  } else if (min.node.size < 1) {
    m1 <- quantile(out$size.node, min.node.size)
    out <- filter(out, size.node > m)
  } else {
    out <- filter(out, size.node > min.node.size)
  }
  
  if (is.factor(y)) 
    out <- mutate(out, prediction = prediction - 1)
  
  return(out)
}

quantileGrid <- function(x, grid.size, interact) {
  stopifnot(length(interact) == 2)
  grid.size <- grid.size + 1
  grids <- list()
  grids$g1 <- quantile(x[,interact[1]], probs=seq(0, 1, length.out=grid.size))
  grids$g2 <- quantile(x[,interact[2]], probs=seq(0, 1, length.out=grid.size))
  return(grids)
}
